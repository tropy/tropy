#!/usr/bin/env node

import { join, dirname, relative, resolve } from 'node:path'
import process from 'node:process'
import { program } from 'commander'
import shx from 'shelljs'

import pkg from '../package.json' with { type: 'json' }
import { ROOT, bail, check, say, setLogSymbol } from './util.js'
import { createLogger } from '../src/common/log.js'
import { compact, strftime } from '../src/common/util.js'

setLogSymbol('db')
createLogger({ level: 'warn' })

const cwd = process.cwd()
const SCHEMA = join(ROOT, 'db', 'schema')
const MIGRATE = join(ROOT, 'db', 'migrate')

const APPLICATION_ID = Buffer.from([0xDA, 0xED, 0xA1, 0x05]).readInt32BE()


global.ARGS = global.ARGS || {
  environment: 'production',
  locale: 'en'
}

program
  .name('tropy-db')
  .description('tropy db script utilities')

program
  .command('create')
  .option('-D, --domain <string>', 'db schema domain', 'project')
  .option('-F, --file <string>', 'database file')
  .option('-f, --force', 'overwrite file if exits', false)
  .option('-N, --name <string>', 'project name', 'Tropy')
  .action(async (opts) => {
    let file = opts.file ?
      resolve(opts.file) :
      join(ROOT, 'db', `${opts.domain}.db`)

    if (opts.force)
      shx.rm('-f', file)

    switch (opts.domain) {
      case 'project': {
        let { create } = await import('../src/common/project.js')
        let { name } = opts
        await create(file, join(SCHEMA, 'project.sql'), ROOT, { name })
        say(`created project "${name}" at ${relative(cwd, file)}`)
        break
      }
      case 'ontology': {
        let { Database } = await import('../src/common/db.js')
        let { create } = await import('../src/models/ontology.js')
        let path = await Database.create(file, create)
        say(`created ontology at ${relative(cwd, path)}`)
        break
      }
      default:
        bail(`unknown domain: ${opts.domain}`)
    }
  })

program
  .command('migrate')
  .description('migrate the db schema file')
  .option('-D, --domain <string>', 'db schema domain', 'project')
  .option('--sqlite3 <string>', 'sqlite3 executable', 'sqlite3')
  .action(async (opts) => {
    let { Database } = await import('../src/common/db.js')
    let schema = join(SCHEMA, `${opts.domain}.sql`)

    let tmp = join(ROOT, 'tmp.db')

    shx.rm('-f', tmp)
    shx.rm('-f', schema)

    let db = new Database(tmp)

    try {
      await db.migrate(join(MIGRATE, opts.domain))
      let { user_version: version } = await db.get('PRAGMA user_version')

      new shx.ShellString(`--
-- This file is auto-generated by executing all current
-- migrations. Instead of editing this file, please create
-- migrations to incrementally modify the database, and
-- then regenerate this schema file.
--
-- To create a new empty migration, run:
--   node scripts/db migrate --domain ${opts.domain}
--
-- To re-generate this file, run:
--   node scripts/db migrate --domain ${opts.domain}
--

PRAGMA encoding = 'UTF-8';
PRAGMA application_id = ${APPLICATION_ID};

-- Save the current migration number (legacy)
PRAGMA user_version = ${version};

-- Load sqlite3 .dump
`
      ).to(schema)

      shx.exec(`${opts.sqlite3} ${tmp} .dump >> ${schema}`)
      new shx.ShellString('PRAGMA foreign_keys=ON;').toEnd(schema)

      shx.sed('-i',
        'PRAGMA writable_schema=OFF;',
        'PRAGMA writable_schema=RESET;',
        schema)

      say(`migrated ${opts.domain} to #${version}`)
      say(`schema saved as ${relative(cwd, schema)}`)

    } catch (e) {
      say(`migration failed: ${e.message}`)
      say(e.stack)
    } finally {
      if (db) await db.close()
      shx.rm('-f', tmp)
    }
  })

program
  .command('viz')
  .option('-D, --domain <string>', 'db schema domain', 'project')
  .option('-F, --file <string>', 'database file')
  .option('-O, --out <string>', 'pdf file')
  .action(async (opts) => {
    let { Database } = await import('../src/common/db.js')

    let file = opts.file || join(ROOT, 'db', `${opts.domain}.db`)
    let pdf = opts.out || join(ROOT, 'doc', `${opts.domain}.db.pdf`)

    check(shx.test('-f', file), `database file ${file} not found`)
    shx.mkdir('-p', dirname(pdf))

    let db = new Database(file)

    try {
      let version = await db.version()

      shx.exec([
        'npx sqleton',
        `-t "${pkg.productName} ${opts.domain}#${version}"`,
        '-f "Helvetica Neue"',
        `-o ${pdf}`,
        file
      ].join(' '))

      say(`${opts.domain} db schema visual saved as ${relative(cwd, pdf)}`)

    } finally {
      await db.close()
    }
  })

program
  .command('migration')
  .description('create a new migration file')
  .argument('[name]', 'a name for the migration')
  .option('-D, --domain <string>', 'db schema domain', 'project')
  .option('--type <string>', 'migration type', 'sql')
  .option('-F, --file <string>', 'database file')
  .action(async (name, opts) => {

    check(opts.type === 'sql' || opts.type === 'js',
      `migration type '${opts.type}' not supported`)

    let file = compact([strftime('%y%m%d%H%M'), name, opts.type]).join('.')
    let path = join(MIGRATE, opts.domain, file)

    new shx.ShellString(
      (opts.type === 'js') ?
        `// ${file}
export async function up(tx) {
}` : `-- ${file}`).to(path)

    say(`migration saved as ${relative(cwd, path)}`)
  })

await program.parseAsync(process.argv)
